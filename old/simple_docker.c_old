#include <sched.h>
#include <cstdio>
#include <cstring>
#include <cerrno>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/mount.h>

void unshare_uts_namespace() {
  if(0 != unshare(CLONE_NEWUTS)) {
    fprintf(stderr, "%s\n", "UTS unshare has failed");
    exit(1);
  }

  const char* hostname = "simple_docker";
  if(-1 == sethostname(hostname, strlen(hostname))) {
    fprintf(stderr, "%s\n", "sethostname has failed");
    exit(1);
  }
}

void unshare_pid_namespace() {
  if(0 != unshare(CLONE_NEWPID)) {
    fprintf(stderr, "%s\n", "PID unshare has failed");
    exit(1);
  }
}

void unshare_mount_namespace() {
  if(0 != unshare(CLONE_NEWNS)) {
    fprintf(stderr, "%s\n", "NS unshare has failed");
    exit(1);
  }
}

void unshare_user_namespace() {
  if(0 != unshare(CLONE_NEWUSER)) {
    fprintf(stderr, "%s\n", "USER unshare has failed");
    exit(1);
  }
}

void unshare_namespaces() {
  unshare_user_namespace();
  unshare_uts_namespace();
  unshare_pid_namespace();
  unshare_mount_namespace();
}

void chroot_to_fs(char* fs_path) {
  if(-1 == chroot(fs_path)) {
    fprintf(stderr, "%s\n", "chroot has failed");
    exit(1);
  }

  if(-1 == chdir("/")) {
    fprintf(stderr, "%s\n", "chdir has failed");
    exit(1);
  }
}

void mount_proc() {
  if(0 != mount("none", "/proc", "proc", 0, NULL)) {
    fprintf(stderr, "%s\n", "mounting proc has failed");
    exit(1);
  }
}

void mount_root() {
  if(0 != mount("none", "/", NULL, 0, NULL)) {
    fprintf(stderr, "%s\n", "mounting root has failed");
    exit(1);
  }
}

void print_uid_map(int pid) {

    char mapping[20];
    sprintf(mapping, "0 %d 1", pid);
    printf("%s\n", mapping);

    char path[100];
    sprintf(path, "/proc/%d/uid_map", pid);

    printf("path: %s\n", path);
    char ch;

    FILE *fp = fopen(path, "r");
    printf("content1\n");
    while ((ch = fgetc(fp) )!= EOF)
    {
       printf ("%c", ch);
    }

    printf("End of file\n" );
    fclose(fp);

}

void map_id_to_root() {
  int pid = getpid();
  int uid = getuid();

  setuid(0);
  print_uid_map (getpid());

  char mapping[20];
  sprintf(mapping, "0 %d 1", uid);
  printf("%s\n", mapping);

  char path[100];
  sprintf(path, "/proc/%d/uid_map", pid);

  printf("path: %s\n", path);
  char ch;

  FILE *fp = fopen(path, "w+");
  if (!fp) {
    printf("Couldn't open file.\n");
  }

  // int written = fprintf(fp, "%s\n", mapping);
  //
  // if (written <= 0){
  //   printf("Couldnt write\n");
  // }

  if (fclose(fp) != 0) {
    printf("Coudln't close file.\n");
    exit(1);
  }
}

void start_simple_docker(char* fs_path, char* command, char** args) {
  // map_id_to_root();

  int uid = getuid();
  printf("==> uid1: %d\n", uid);

  unshare_namespaces();
  uid = getuid();
  printf("==> uid1: %d\n", uid);

  map_id_to_root();
  uid = getuid();
  printf("==> uid2: %d\n", uid);

  pid_t first_child_pid = fork();
  if(-1 == first_child_pid) {
    fprintf(stderr, "%s\n", "couldn't fork PID 1");
    exit(1);
  }

  int status;
  if(first_child_pid == 0) {
    // map_id_to_root();
    printf("hello\n");

    int uid = getuid();
    printf("uid2: %d\n", uid);

    pid_t second_child_pid = fork();
    if(-1 == second_child_pid) {
      fprintf(stderr, "%s\n", "couldn't fork PID 2");
      exit(1);
    }
    uid = getuid();
    printf("uid3: %d\n", uid);

    // map_id_to_root();

    // unshare_namespaces();

    // chroot_to_fs(fs_path);
    // mount_proc();

    uid = getuid();
    printf("uid4: %d\n", uid);

    if(second_child_pid == 0 ){
      if(-1 == execvp(command, args)) {
        fprintf(stderr, "%s\n", "couldn't execvp");
        exit(1);
      }

      unshare_namespaces();
      map_id_to_root();
      uid = getuid();
      printf("==> uid3: %d\n", uid);
    }
    while (wait(&status) != -1 || errno != ECHILD);
    fprintf(stderr, "init died\n");
  }
  wait(&status);
}

int main(int argc, char** argv) {
  start_simple_docker(argv[1], argv[2], &argv[2]);
  return 0;
}
